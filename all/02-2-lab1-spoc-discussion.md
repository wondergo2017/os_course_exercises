# lec4: lab1 SPOC思考题

## **提前准备**
（请在上课前完成）

 - 完成lec4的视频学习和提交对应的在线练习
 - git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises in github repos。这样可以在本机上完成课堂练习。
 - 了解x86的保护模式，段选择子，全局描述符，全局描述符表，中断描述符表等概念，以及如何读写，设置等操作
 - 了解Linux中的ELF执行文件格式
 - 了解外设:串口，并口，时钟，键盘,CGA，已经如何对这些外设进行编程
 - 了解x86架构中的mem地址空间和io地址空间
 - 了解x86的中断处理过程（包括硬件部分和软件部分）
 - 了解GCC的x86/RV内联汇编
 - 了解C语言的可函数变参数编程
 - 了解qemu的启动参数的含义
 - 在piazza上就lec3学习中不理解问题进行提问
 - 学会使用 qemu
 - 在linux系统中，看看 /proc/cpuinfo的内容

## 思考题

### 启动顺序

1. **x86段寄存器的字段含义和功能有哪些？**

   - CS(代码段寄存器)：保存代码的段基址，与IP一同使用来找到下一条指令
   - SS(堆栈段寄存器)：保存堆栈的段基址，与BP和SP一同使用来找到堆栈的位置
   - DS(数据段寄存器)：保存数据的段基址，可以在存取的时候用以找到操作数的地址
   - ES(附加段寄存器)：指向附加数据的段基址

2. **x86描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？**

   - 含义
     - DPL规定段本身具有的特权级，程序若要访问，必须有更高的特权级。
     - RPL为程序访问段时请求使用的特权级
     - CPL为程序本身的特权级

   - 存放位置

     - DPL存放在CS和SS段寄存器的最低两位（总共有4个特权级）
     - RPL存放在段寄存器的最低两位

   - 访问条件

     - CPL为程序的特权级，在访问段的时候要检查该段的特权级DPL，只有在CPL<=DPL的时候，程序才有可能访问该段。若满足条件，进一步，程序会使用RPL为访问该段发出请求，只有RPL<=DPL的时候，程序可以访问该段。

   - RPL作用

     - 处理低特权程序调用OS来访问高特权程序的内层数据的问题。
       - 调用者调用OS接口的时候，会将自身的RPL传给OS，而OS使用RPL来继续访问另一个程序；而此时DPL已经不是低特权程序的DPL，而是OS的，若采用DPL的话，那么就会出现低特权程序所有数据段都可以（间接）访问的BUG。
     - 处理跨权限访问代码段问题
       - 必须DPL==RPL==CPL的时候才能进行访问

     

3. **分析可执行文件格式elf的格式（无需回答）**

### 4.1 C函数调用的实现

### 4.2 x86中断处理过程

1. **x86/RV中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？**

   当前程序使用的用户态的ss和esp，以及相关现场信息，即依次压入当前被打断程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息

   用户态中断时，CPU会从当前程序的TSS信息里取得该程序的内核栈地址，即包括内核态的ss和esp的值，并立即将系统当前使用的栈切换成新的内核栈。这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的用户态的ss和esp压到新的内核栈中保存起来；

   而内核态中断，则则继续使用内核栈。

2. **为什么在用户态的中断响应要使用内核堆栈？**

   为了保护中断服务程序的安全。

3. **x86中trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?**

   trap gate还会增加一个额外的检查：门的DPL必须具有与CPL相同或更低的特权。

   否则可能用户代码随意触发中断。

### 4.3 练习四和五 ucore内核映像加载和函数调用栈分析

1. **ucore中，在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？**

   ebp可以直接通过汇编代码得到，而这个使用内联实现，而若非内联，那么得到的ebp是调用函数后ebp而非原本的ebp，也即错误

   然而eip的获取没有对应的汇编代码，一般是通过call（自然将ret的地址压入栈），再mov取出其值就是eip来获取。这种方式正好可以通过函数调用的方式来实现。

### 4.4 练习六 完善中断初始化和处理

1. **CPU加电初始化后中断是使能的吗？为什么？**

   不是，因为BOOT还要在自检之后以特权级建立中断向量表等，否则中断无法找到对应处理程序。

## 开放思考题

1. **在ucore/rcore中如何修改lab1, 实现在出现除零异常时显示一个字符串的异常服务例程？**

2. **在ucore lab1/bin目录下，通过`objcopy -O binary kernel kernel.bin`可以把elf格式的ucore kernel转变成体积更小巧的binary格式的ucore kernel。为此，需要如何修改lab1的bootloader, 能够实现正确加载binary格式的ucore OS？ (hard)**

3. **GRUB是一个通用的x86 bootloader，被用于加载多种操作系统。如果放弃lab1的bootloader，采用GRUB来加载ucore OS，请问需要如何修改lab1, 能够实现此需求？ (hard)**

4. **如果没有中断，操作系统设计会有哪些问题或困难？在这种情况下，能否完成对外设驱动和对进程的切换等操作系统核心功能？**

   没有中断的话，进程切换可以采取和OS“协作”的方式，让程序遵守一些OS的“约定”，然而这是十分不靠谱的。外设驱动也可以采用轮询、DMA等方式处理，但是相应地会付出很多代价。

## 课堂实践
### **练习一**
**在Linux系统的应用程序中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。**

### **练习二**

**在ucore/rcore内核中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。**
